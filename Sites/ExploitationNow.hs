module Sites.ExploitationNow
    ( exploitationNow
    ) where

import Network.HTTP.Types.URI (decodePathSegments)

import Data.Maybe (catMaybes)

import Data.List (isInfixOf, isPrefixOf, isSuffixOf)
import qualified Data.List as DL
import qualified Data.List.Split as SL

import Text.XML.HXT.Core

import Control.Concurrent (forkIO, killThread)
import Control.Concurrent.STM.TBMChan
import Control.Monad.STM (atomically)
import qualified Control.Monad as CM

import qualified Data.Text as T
import qualified Data.ByteString.Lazy.UTF8 as UL
import qualified Data.ByteString.UTF8 as US

import Control.Exception (throw)

-- Local imports
import Types
import Sites.Util

--
-- Exploitation Now
--
exploitationNow = Comic
    { comicName = "Exploitation Now"
    , seedPage = "http://www.exploitationnow.com/2000-07-07/9"
    , seedType = undefined

    , pageParse = exploitationPageParse
    }

exploitationPageParse :: ReplyType t -> IO [FetchType t]
exploitationPageParse (WebpageReply html _) = do
    let doc = readString [withParseHTML yes, withWarnings no] $ UL.toString html
    next <- runX $ doc //> nextPage
    img <- runX $ doc //> comic
    vol <- (exploitationNowVol . concat) `fmap` (runX $ doc //> whichVol)

    -- Do we have any comic we want to store to disk?
    putStrLn "Fetched Urls:"
    mapM_ putStrLn img
    mapM_ putStrLn next

    return $ (map (\a -> Webpage a undefined) next) ++ (map (\a -> Image a $ comicFileName vol a) img)

   where
    nextPage = hasName "a" >>> hasAttrValue "class" (isInfixOf "navi-next") >>> hasAttr "href" >>> getAttrValue "href"
    comic = hasAttrValue "id" (== "comic") >>> hasName "div" //> hasName "img" >>> hasAttr "src" >>> getAttrValue "src"
    comicFileName vol url = ComicTag (T.pack "exploitation_now") Nothing vol Nothing (Just $ last $ decodePathSegments $ US.fromString url)
    whichVol =
        hasName "body"
        >>> hasAttr "class"
        >>> getAttrValue "class"
        >>> arr words
        >>> arr (filter (isPrefixOf "single-category"))
        >>> arr (filter (not . isSuffixOf "comic"))
        >>> arr (filter (not . isSuffixOf "comics"))
        >>> arr (filter (not . isSuffixOf "uncategorized"))
        >>> arr concat

    exploitationNowVol :: String -> Maybe UnitTag
    exploitationNowVol "single-category-act-one"         = Just $ UnitTag 1 $ Just $ T.pack "Act One"
    exploitationNowVol "single-category-act-two"         = Just $ UnitTag 2 $ Just $ T.pack "Act Two"
    exploitationNowVol "single-category-intermission-i"  = Just $ UnitTag 3 $ Just $ T.pack "Intermission I"
    exploitationNowVol "single-category-act-three"       = Just $ UnitTag 4 $ Just $ T.pack "Act Three"
    exploitationNowVol "single-category-intermission-ii" = Just $ UnitTag 5 $ Just $ T.pack "Intermission II"
    exploitationNowVol "single-category-act-four"        = Just $ UnitTag 6 $ Just $ T.pack "Act Four"
    exploitationNowVol _ = Nothing
