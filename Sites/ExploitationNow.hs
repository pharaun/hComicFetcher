module Sites.ExploitationNow
    ( exploitationNow
    ) where

import Network.HTTP.Types.URI (decodePathSegments)

import Data.Maybe (catMaybes)

import Data.List (isInfixOf, isPrefixOf, isSuffixOf)
import qualified Data.List as DL
import qualified Data.List.Split as SL

import Text.XML.HXT.Core

import Control.Concurrent (forkIO, killThread)
import Control.Concurrent.STM.TBMChan
import Control.Monad.STM (atomically)
import qualified Control.Monad as CM

import qualified Data.Text as T
import qualified Data.ByteString.Lazy.UTF8 as UL
import qualified Data.ByteString.UTF8 as US

import Control.Exception (throw)

-- Local imports
import Types
import Sites.Util

--
-- Exploitation Now
--
exploitationNow = Comic
    { comicName = "Exploitation Now"
    , seedPage = "http://www.exploitationnow.com/2000-07-07/9"
    , seedType = undefined

    , pageParse = exploitationPageParse
    }

exploitationPageParse :: ReplyType t -> IO [FetchType t]
exploitationPageParse (WebpageReply html _) = do
    let doc = readString [withParseHTML yes, withWarnings no] $ UL.toString html
    next <- runX $ doc //> nextPage
    img <- runX $ doc //> comic
    vol <- (exploitationNowVol . concat) `fmap` (runX $ doc //> whichVol)

    -- Do we have any comic we want to store to disk?
    putStrLn "Fetched Urls:"
    mapM_ putStrLn img
    mapM_ putStrLn next

    return $ map (\a -> Webpage a undefined) next ++ map (\a -> Image a $ comicFileName vol a) img

   where
    nextPage = hasName "a" >>> hasAttrValue "class" (isInfixOf "navi-next") >>> hasAttr "href" >>> getAttrValue "href"
    comic = hasAttrValue "id" (== "comic") >>> hasName "div" //> hasName "img" >>> hasAttr "src" >>> getAttrValue "src"
    comicFileName chp url = ComicTag (T.pack "exploitation_now") Nothing Nothing chp (Just $ last $ decodePathSegments $ US.fromString url)
    whichVol =
        hasName "body"
        >>> hasAttr "class"
        >>> getAttrValue "class"
        >>> arr words
        >>> arr (filter (isPrefixOf "single-category"))
        >>> arr (filter (not . isSuffixOf "comic"))
        >>> arr (filter (not . isSuffixOf "comics"))
        >>> arr (filter (not . isSuffixOf "uncategorized"))
        >>> arr concat

    exploitationNowVol :: String -> Maybe UnitTag
    exploitationNowVol "single-category-act-one"         = Just $ UnitTag [StandAlone $ Digit 1 Nothing Nothing] (Just $ T.pack "Act One")
    exploitationNowVol "single-category-act-two"         = Just $ UnitTag [StandAlone $ Digit 2 Nothing Nothing] (Just $ T.pack "Act Two")
    exploitationNowVol "single-category-intermission-i"  = Just $ UnitTag [StandAlone $ Digit 3 Nothing Nothing] (Just $ T.pack "Intermission I")
    exploitationNowVol "single-category-act-three"       = Just $ UnitTag [StandAlone $ Digit 4 Nothing Nothing] (Just $ T.pack "Act Three")
    exploitationNowVol "single-category-intermission-ii" = Just $ UnitTag [StandAlone $ Digit 5 Nothing Nothing] (Just $ T.pack "Intermission II")
    exploitationNowVol "single-category-act-four"        = Just $ UnitTag [StandAlone $ Digit 6 Nothing Nothing] (Just $ T.pack "Act Four")
    exploitationNowVol _ = Nothing
